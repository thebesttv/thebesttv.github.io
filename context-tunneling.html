<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-09-26 17:06 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Context Tunneling</title>
<meta name="author" content="thebesttv" />
<meta name="generator" content="Org Mode" />
<!-- CSS -->
<link rel="stylesheet" type="text/css" href="https://unpkg.com/latex.css/style.css"/>
<link rel="stylesheet" type="text/css" href="css/org-default.css"/>
<link rel="stylesheet" type="text/css" href="css/style.css"/>
<!-- Google tag (gtag.js) -->
<script async src=<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<nav class="org-center">
<a href="index.html">Home</a>
</nav>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Context Tunneling</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org7ce7c34">1. Context Tunneling</a></li>
<li><a href="#org36b1483">2. Feature</a>
<ul>
<li><a href="#org1650981">2.1. Feature 的组合</a></li>
<li><a href="#org98dbffd">2.2. 使用 feature 生成 \(\mathcal{T}\)</a></li>
</ul>
</li>
<li><a href="#org36c3e84">3. 算法</a></li>
</ul>
</div>
</nav>
<p>
论文干了两件事
</p>
<ul class="org-ul">
<li>使用 context-tunneling 代替传统的 k-limiting 进行指针分析</li>
<li>提出学习 context-tunneling 策略的算法</li>
</ul>

<p>
context tunneling: updates contexts <b><b>selectively</b></b> and decides when to
<b><b>preserve contexts without modification</b></b>.  dramatic increase in both
precision and scalability can be gained by maintaining important context
elements only
</p>

<div id="outline-container-org7ce7c34" class="outline-2">
<h2 id="org7ce7c34"><span class="section-number-2">1.</span> <a href="#org7ce7c34">Context Tunneling</a></h2>
<div class="outline-text-2" id="text-1">
<p>
使用 context-tunneling 的指针分析, 相比与传统的 k-limiting 多了一个输入:
tunneling relation \(\mathcal{T} \subseteq \mathbb{M} \times \mathbb{M}\),
是方法集 \(\mathbb{M}\) 上的二元关系.
</p>

<p>
\(\mathcal{T}\) 中的每个元素形如 \((m_1, m_2)\), 表示当 \([c]:m_1\) 调用 \(m_2\)
时, \(m2\) 的 context 不重要, 需要使用 tunneling, 即 \(m_2\) 继承 \(m_1\) 的
context \([c]\).  而不在 \(\mathcal{T}\) 中的函数调用, 如 \(m_3\) 调用 \(m_2\)
或 \(m_1\) 调用 \(m_3\), 则和传统的 k-limiting 方法一样, 产生新的 context
\([c']\).
</p>
</div>
</div>

<div id="outline-container-org36b1483" class="outline-2">
<h2 id="org36b1483"><span class="section-number-2">2.</span> <a href="#org36b1483">Feature</a></h2>
<div class="outline-text-2" id="text-2">
<p>
Feature 可以匹配代码中的一些 method.
</p>

<p>
共有 10 + 13 个 atomic feature, 分为两类
</p>
<ul class="org-ul">
<li>A类: signature feature, 语法上的, 匹配 “lang”, “void”, “()” 等字符串</li>
<li>B类: addition feature, 语义上的, 如包含 field store 的 method, 或 static method</li>
</ul>
<p>
这23个 atomic feature 组成集合 \(\mathbb{A}\).
</p>
</div>

<div id="outline-container-org1650981" class="outline-3">
<h3 id="org1650981"><span class="section-number-3">2.1.</span> <a href="#org1650981">Feature 的组合</a></h3>
<div class="outline-text-3" id="text-2-1">
<p>
使用析取范式将 atomic feature 组合可以生成更复杂的 feature:
\[ f = \bigvee_i \bigwedge_j a_{i,j}, \]
也就是将 atomic feature \(a_{i,j} \in \mathbb{A}\) 用与/或连接.
</p>
</div>
</div>

<div id="outline-container-org98dbffd" class="outline-3">
<h3 id="org98dbffd"><span class="section-number-3">2.2.</span> <a href="#org98dbffd">使用 feature 生成 \(\mathcal{T}\)</a></h3>
<div class="outline-text-3" id="text-2-2">
<p>
Tunneling 所需的 \(\mathcal{T}\) 由 feature 生成.
算法的目的就是学习出两个 feature \(\Pi = \langle f_1, f_2 \rangle\).
有了 \(\Pi\), 就可以对不同的程序生成对应的 \(\mathcal{T}\) 用于指针分析.
</p>

<p>
\(\Pi\) 中的 \(f_1\), \(f_2\) 分别匹配
</p>
<ol class="org-ol">
<li>methods that increase the analysis precision by <b><b>passing their
contexts to others</b></b> (m1)</li>
<li>methods that increase the analysis precision by <b><b>inheriting contexts
from others</b></b> (m2)</li>
</ol>

<p>
给定程序 \(P\), 生成对应的 \(\mathcal{T}\):
\[ \mathcal{H}_\Pi (P) = \{ (m_1, m_2) \in \mathbb{M}_P \times \mathbb{M}_P
   \mid m_1 \in [\![ f_1 ]\!]_P \vee m_2 \in [\![ f_2 ]\!]_P \}, \]
其中 \(\mathbb{M}_P\) 为 \(P\) 的 method 集, \(\mathcal{H}_\Pi\) 为生成函数,
\([\![f]\!]_P\) 匹配 \(P\) 中所有符合 \(f\) 的方法.
</p>
</div>
</div>
</div>

<div id="outline-container-org36c3e84" class="outline-2">
<h2 id="org36c3e84"><span class="section-number-2">3.</span> <a href="#org36c3e84">算法</a></h2>
<div class="outline-text-2" id="text-3">
<p>
A <b><b>data driven</b></b> approach: automatically search for high-quality
heuristics over the non-monotonic space of context tunneling.
</p>

<p>
寻找 \(\Pi\) 是一个最优化问题, 需要最大化 accuracy, 同时速度不能比传统的
k-limiting 慢.  有两个挑战
</p>
<ul class="org-ul">
<li>the effectiveness of context-tunneling is very sensitive to the choice
of important context elements</li>
<li>precision is not monotonically increasing with respect to the ordering
of the choices (非单调)
<ul class="org-ul">
<li>空 policy (\(\mathcal{T} = \emptyset\))
表示从不使用 tunneling, 即为传统的 k-limiting</li>
<li>满 policy (\(\mathcal{T} = \mathbb{M}_P \times \mathbb{M}_P\))
表示永远使用 tunneling, 即永远继承最开始的 empty context, 也就变成
context insensitive</li>
<li>空 policy 和满 policy 既不是最好也不是最差</li>
<li>一个 policy (\(\mathcal{T}\)), 如果加上/减少一个元素 \((m_1, m_2)\),
精度提高还是降低不确定</li>
</ul></li>
</ul>


<p>
论文提出非贪心的机器学习算法来应对挑战.
</p>

<p>
算法整体框架如图 <a href="#org1d10c58">1</a>, 根据给定的指针分析算法 \(F\), atomic feature 集合
\(\mathbb{A}\), 从一系列输入程序 \(\mathbf{P} = \{P_1, P_2, \cdots\}\) 中学
习, 最后生成 \(\Pi\).
</p>


<figure id="org1d10c58">
<img src="./context-tunneling/algo-overall.png" alt="algo-overall.png" width="100%" style="margin-left: auto; margin-right: auto;">

<figcaption><span class="figure-number">Figure 1: </span>整体框架</figcaption>
</figure>

<p>
主算法为 \(\text{LearnParameter}(i, f_2, F, \mathbf{P}, \mathbb{A})\), 表
示当前学习的是 \(\Pi\) 中的 \(f_i\) (也是返回值), 会被调用两次:
</p>
<ul class="org-ul">
<li>第一次 \(\text{LearnParameter}(2, false, F, \mathbf{P}, \mathbb{A})\),
表示学习 \(f_2\)</li>
<li>第二次 \(\text{LearnParameter}(1, f_2, F, \mathbf{P}, \mathbb{A})\),
表示基于之前学习的 \(f_2\) 学习 \(f_1\)</li>
</ul>
<p>
两次学习的结果组合成 \(\Pi = \langle f_1, f_2 \rangle\).
</p>

<p>
\(\text{LearnParameter}(i, f_2, F, \mathbf{P}, \mathbb{A})\) 见图
<a href="#orgbe8f1d2">2</a>, 主要步骤
</p>
<ul class="org-ul">
<li>初始化 \(f_1 = false\), \(\Pi = \langle f_1, f_2 \rangle\)</li>
<li>初始化后开始学习 \(f_i\)</li>
<li>构造 seed feature 集 \(W\), 表示有可能让结果更好的 atomic feature</li>
<li>每次选出一个可能效果最好的 seed feature \(s\), 试图使用其他 atomic
feature 来 refine \(s\), 让指针分析更精确.
如 \(s = a_0\), refine 时多加了 \(a_1\), \(a_2\), 则生成\(f_i \vee (a_0
  \wedge a_1 \wedge a_2)\)</li>
<li>如果 refine 的结果更优的话, 就更新 \(f_i\)</li>
</ul>


<figure id="orgbe8f1d2">
<img src="./context-tunneling/algo-learnSingle.png" alt="algo-learnSingle.png" width="100%" style="margin-left: auto; margin-right: auto;">

<figcaption><span class="figure-number">Figure 2: </span>Learn single parameter</figcaption>
</figure>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr><table class="postamble">
  <tr><td class="org-right">Author</td><td class="org-left">thebesttv</td></tr>
  <tr><td class="org-right">Created</td><td class="org-left">2022-09-25 23:01</td></tr>
  <tr><td class="org-right">Modified</td><td class="org-left">2022-09-26 16:17</td></tr>
  <tr><td class="org-right">Generated</td><td class="org-left">2022-09-26 17:06</td></tr>
  <tr><td class="org-right">Version</td><td class="org-left"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.2 (<a href="https://orgmode.org">Org</a> mode 9.5.5)</td></tr>
  <tr><td class="org-right">Raw</td><td class="org-left"><a href="https://github.com/thebesttv/thebesttv.github.io/blob/main/context-tunneling.org">context-tunneling.org</a></td></tr>
</table>
</div>
</body>
</html>
